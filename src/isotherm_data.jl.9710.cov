        - struct AbsorbedIsothermData{TT} <: Tables.AbstractColumns
        3     p::Vector{TT}
        -     l::Vector{TT}
        -     T::Vector{TT}
        -     p_label::Symbol
        -     l_label::Symbol
        -     T_label::Symbol
        - end
        -
        - const AdsIsoTData = AbsorbedIsothermData
        -
        - #= function isotherm_data(p::P,l::L,p_label::Symbol,l_label::Symbol) where {P,L}
        -     return AbsorbedIsothermData(p,l,zeros(eltype(p),length(p)),p_label,l_label,:T)
        - end =#
        -
        - function isotherm_data(p::P, l::L, p_label::Symbol, l_label::Symbol; fill_T = zeros(eltype(p))) where {P, L}
        -
        -     return AbsorbedIsothermData(p, l, fill(fill_T, length(p)), p_label, l_label, :T)
        -
        - end
        -
        - function merge_isotherm_data(tables::AdsIsoTData{TT}...) where TT
        -     row_tables = map(Tables.rowtable, tables)
        -     concatenated_rows = vcat(row_tables...)
        -     return Tables.columntable(concatenated_rows)
        - end
        -
        4 function isotherm_data(p::P,l::L,t::T,p_label::Symbol,l_label::Symbol,T_label::Symbol) where {P,L,T}
        4     @assert length(p) == length(l) == length(t)
        4     @assert p_label != l_label
        4     @assert p_label != T_label
        4     @assert l_label != T_label
        4     pmin = minimum(p)
        3     if pmin < 0
        0         throw(DomainError(pmin,"adsorbed input pressure must be positive"))
        -     end
        3     TT = Base.promote_eltype(p,l,t)
        3     n = length(p)
        6     pp = Vector{TT}(undef,n)
        6     ll = Vector{TT}(undef,n)
        6     tt = Vector{TT}(undef,n)
        -
        6     if !issorted(p)
        0         idx = sortperm(pp)
        0         lv,pv,tv = view(l,idx),view(p,idx),view(t,idx)
        0         ll .= lv
        0         pp .= pv
        0         tt .= tv
        -     else
        6         pp .= p
        6         ll .= l
        3         tt .= t
        -     end
        3     return AbsorbedIsothermData{TT}(pp,ll,tt,p_label,l_label,T_label)
        - end
        -
        - isotherm_data(p::AbstractVector,l::AbstractVector) = isotherm_data(p,l,zeros(eltype(p),length(p)))
        - isotherm_data(p::AbstractVector,l::AbstractVector,T::AbstractVector) = isotherm_data(p,l,T,:p,:l,:T)
        -
        - function isotherm_data(table,p_label::String,l_label::String,T_label::String)
        -     return isotherm_data(table,Symbol(p_label),Symbol(l_label),Symbol(T_label))
        - end
        -
        4 function isotherm_data(table,p_label::Symbol,l_label::Symbol,T_label::Symbol)
        4     if Tables.istable(table)
        4         p = Tables.getcolumn(table,p_label)
        4         l = Tables.getcolumn(table,l_label)
        4         T = Tables.getcolumn(table,T_label)
        4          return isotherm_data(p,l,T,p_label,l_label,T_label)
        -     else
        0         throw(ArgumentError("table must be a Tables.jl table"))
        -     end
        - end
        -
        - function isotherm_data(table)
        -     return isotherm_data(table,keys(table)...)
        - end
        -
        - #Tables.jl api, column access
        -
        - Tables.istable(::Type{<:AbsorbedIsothermData}) = true
        - Tables.columnaccess(::Type{<:AbsorbedIsothermData}) = true
        1 function Tables.schema(m::AbsorbedIsothermData{T}) where {T}
        -
        1     Tables.Schema(Tables.columnnames(m), (T,T,T))
        - end
        1 Tables.columns(m::AbsorbedIsothermData) = m
        -
       25 function Tables.getcolumn(table::AbsorbedIsothermData, nm::Symbol)
       25     p_label,l_label,T_label = getfield(table,4),getfield(table,5),getfield(table,6)
       25     if nm == p_label
        9         return getfield(table,1)
       16     elseif nm == l_label
        8         return getfield(table,2)
        8     elseif nm == T_label
        8         return getfield(table,3)
        -     else
        0         throw(KeyError(nm))
        -     end
        - end
        -
       12 function Tables.getcolumn(table::AbsorbedIsothermData, nm::Int)
       12     if nm == 1 || nm == 2 || nm == 3
       12         return getfield(table,nm)
        -     else
        0         throw(BoundsError(table,nm))
        -     end
        - end
        -
        - function Tables.getcolumn(m::AbsorbedIsothermData, ::Type{T}, col::Int, nm::Symbol) where {T}
        -     return Tables.getcolumn(m, col)
        - end
        -
        3 Tables.columnnames(table::AbsorbedIsothermData) = (getfield(table,4),getfield(table,5),getfield(table,6))
        -
        - Base.eltype(::Type{<:AbsorbedIsothermData{T}}) where {T} = T
        3 Base.eltype(::AbsorbedIsothermData{T}) where {T} = T
        -
        4 temperature(m::AbsorbedIsothermData) = Tables.getcolumn(m,3)
        4 loading(m::AbsorbedIsothermData) = Tables.getcolumn(m,2)
        4 pressure(m::AbsorbedIsothermData) = Tables.getcolumn(m,1)
        -
        -
        -
        2 function split_data_by_temperature(data::AdsIsoTData{TT}) where TT
        2     l = loading(data)
        2     p = pressure(data)
        2     t = temperature(data)
        -
        2     unique_temps = sort(unique(t))  # Sort unique temperatures in increasing order
        4     temp_data = Vector{Tuple{Vector{TT}, Vector{TT}}}(undef, length(unique_temps))
        -
        2     for (i, temp) in enumerate(unique_temps)
       10         indices = findall(t .== temp)
       10         l_temp = l[indices]
       10         p_temp = p[indices]
       10         temp_data[i] = (l_temp, p_temp)
       18     end
        -
        2     return unique_temps, temp_data
        - end
        -
        - export AbsorbedIsothermData, isotherm_data, split_data_by_temperature, merge_isotherm_data
