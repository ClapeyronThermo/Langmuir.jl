  9797335 Base.eltype(model::IsothermModel{T}) where T = T
        -
        - function Base.eltype(::Type{M}) where M <: IsothermModel{T} where T
        -     return T
        - end
        -
        - Rgas(model) = 8.31446261815324 #J.mol⁻¹.K⁻¹
        -
        - """
        -     model_length(model::IsothermModel)
        -
        - Returns the amount of parameters necessary to instantiate a `model::IsothermModel`. For simple models, this is equivalent to `fieldcount(typeof(model))`, but composite models (like `MultiSite`), define their own implementation.
        - """
        - #default.
   187960 model_length(::Type{T}) where T <: IsothermModel = _model_length(T)
     1054 model_length(model::IsothermModel) = model_length(typeof(model))
        -
   187960 function _model_length(model::Type{T}) where T <: IsothermModel
   187960     return fieldcount(T)
        - end
        -
    93450 function isotherm_checkbounds(::Type{M},data) where M <: IsothermModel
    93450     lb = isotherm_lower_bound(float(_eltype(data)),M)
    93450     ub = isotherm_upper_bound(float(_eltype(data)),M)
    93450     @inbounds for i in 1:model_length(M)
   389602         if !(lb[i] <= data[i] <= ub[i])
        0             IsothermBoundsError(M,lb[i],ub[i],data[i],i)
        -         end
   685754     end
    93450     return nothing
        - end
        -
        -
        0 function IsothermBoundsError(::Type{M},lb,ub,datai,i) where M <: IsothermModel
        0     description = isotherm_descriptions(M)[i]
        0     symbol = string(fieldname(M,i))
        0     if length(description) != 0
        0         d = lazy"($description) "
        -     else
        0         d = lazy""
        -     end
        0     throw(ArgumentError(lazy"$(nameof(M)): value for the field `$symbol` $(d)is out of the parameter bounds: ($lb <= $datai <= $ub) == false"))
        - end
        -
        - function from_vec(m::IsothermModel,x)
        -     return from_vec(typeof(m),x,true)
        - end
        -
        6 from_vec(m::IsothermModel,x,check) = from_vec(typeof(m),x,check)
        -
   389569 from_vec(::Type{M},p) where {M <: IsothermModel} = from_vec(M,p,true)
        -
    38818 function from_vec(::Type{M},p,check) where {M <: IsothermModel}
   155272     data = ntuple(i -> p[i], model_length(M))
   116454     check && isotherm_checkbounds(M,data)
    38818     return M(data...)
        - end
        -
    54632 function from_vec(::Type{M},p,check) where M <: IsothermModel{T} where T
   327780     data = ntuple(i -> T(p[i]), model_length(M))
   273148     check && isotherm_checkbounds(M,data)
    54632     return M(data...)
        - end
        -
        2 function to_vec!(model::IsothermModel,x)
        2     for i in 1:model_length(model)
        8         x[i] = getfield(model,i)
       14     end
        2     return x
        - end
        -
        2 function to_vec(model::IsothermModel)
        2     x = Vector{eltype(model)}(undef, model_length(model))
        8     to_vec!(model,x)
        2     return x
        - end
        -
        - function to_tuple(model::IsothermModel)
        -     return ntuple(i -> getfield(model,i), model_length(model))
        - end
        -
        - Base.zero(model::M) where M <: IsothermModel = Base.zero(M)
        -
        - function Base.zero(model::Type{M}) where M <: IsothermModel{T} where T
        -     isotherm_zero(T,model)
        - end
        -
        - #when T is not defined (zero(Langmuir))
        - function Base.zero(model::Type{M}) where M <: IsothermModel
        -     isotherm_zero(Float64,model)
        - end
        -
        6 function isotherm_zero(::Type{T},model::Type{M}) where T <: Number where M <: IsothermModel
        6     from_vec(M,ntuple(Returns(zero(T)),model_length(model)))
        - end
        -
     1044 function Base.iszero(model::IsothermModel)
     1044     result = true
     1044     for i in 1:model_length(model)
     3132         result &= iszero(getfield(model,i))
     5220     end
     1044     return result
        - end
        -
        - #default: fill with ones
        - function x0_guess_fit(::Type{T}, data) where T <: IsothermModel
        -     p = pressure(data)
        -     _1 = one(eltype(p))
        -     _ones = ntuple(Returns(_1),model_length(T))
        -     _lb_bounds = 2 .* lower_bound(typeof(_1),T)
        -     v = max.(_ones,_lb_bounds)
        -     return from_vec(T,v)
        - end
        -
        - #Get p, l for the highest temperature in the data set - used for xO_guess_fit
        - function Tmax_data(data)
        -
        -     l, p, t = loading(data), pressure(data), temperature(data)
        -
        -     is_tmax = findall(t .== findmax(t)[1])
        -
        -     l_min, p_min = l[is_tmax], p[is_tmax]
        -
        -     return l_min, p_min
        -
        - end
        -
        -
        -
        - function isotherm_descriptions(::Type{T}) where T <: IsothermModel
        -     return ntuple(Returns(""),model_length(M))
        - end
        -
        - """
        -     isotherm_lower_bound(model::IsothermModel)
        -     isotherm_lower_bound(T,model::IsothermModel)
        -     isotherm_lower_bound(T,::Type{M}) where M <:IsothermModel
        -
        - Returns the lower bound for the parameters of the isotherm model `model` of type `M`. with number type `T`, as a `Ntuple{model_length(M),T}`.
        - The default assumes that all parameters are nonnegative.
        - """
        - function isotherm_lower_bound(model::IsothermModel)
        -     return isotherm_lower_bound(typeof(model))
        - end
        -
        - function isotherm_lower_bound(::Type{T}) where T <: IsothermModel
        -     return isotherm_lower_bound(_eltype(T),T)
        - end
        -
        - function isotherm_lower_bound(::Type{T},m::IsothermModel) where T
        -     return isotherm_lower_bound(T,typeof(m))
        - end
        -
        - function isotherm_lower_bound(::Type{T},::Type{M}) where T where M <: IsothermModel
        -     ntuple(Returns(T(-Inf)),model_length(M))
        - end
        -
        - """
        -     isotherm_upper_bound(model::IsothermModel)
        -     isotherm_upper_bound(T,model::IsothermModel)
        -     isotherm_upper_bound(T,::Type{M}) where M <:IsothermModel
        -
        - Returns the upper bound for the parameters of the isotherm model `model` of type `M`. with number type `T`, as a `Ntuple{model_length(M),T}`.
        - The default assumes no upper bound for the parameters.
        - """
        - function isotherm_upper_bound(model::T) where T <: IsothermModel
        -     return isotherm_upper_bound(typeof(model))
        - end
        -
        - function isotherm_upper_bound(::Type{T}) where T <: IsothermModel
        -     return isotherm_upper_bound(_eltype(T),T)
        - end
        -
        - function isotherm_upper_bound(::Type{T},m::IsothermModel) where T
        -     return isotherm_upper_bound(T,typeof(m))
        - end
        -
        - function isotherm_upper_bound(::Type{T},::Type{M}) where T where M <: IsothermModel
        -     ntuple(Returns(T(Inf)),model_length(M))
        - end
        -
        - """
        -     @with_metadata(struct_expr)
        -
        - macro that allows to define an isotherm model with additional metadata, about parameter bounds and descriptions of parameters:
        -
        - ## Usage:
        -
        - ```julia
        - Langmuir.@with_metadata struct MyIsotherm{T} <: IsothermModel{T}
        -     A::T,(0,1),"field A" #bounds and description provided
        -     B::T #nothing provided
        -     C::T,(1,10) #only bounds provided
        -     D::T,nothing,"field D" #only description provided
        - end
        -
        - from_vec(MyIsotherm,(1,2,3,4)) #ok
        - from_vec(MyIsotherm,(-1,2,3,4)) #ArgumentError: MyIsotherm: value for the field `A` (field A) is out of the parameter bounds: (0.0 <= -1 <= 1.0) == false
        - from_vec(MyIsotherm,(1,2,-3,4)) #ArgumentError: MyIsotherm: value for the field `C` is out of the parameter bounds: (1.0 <= -3 <= 10.0) == false
        - ```
        - """
        - macro with_metadata(_struct_def)
        -     struct_def = copy(_struct_def)
        -     struct_fields = struct_def.args[3]
        -     _lb = Any[]
        -     _ub = Any[]
        -
        -     #X{T} <: IsothermModel{T}
        -     struct_head_def = struct_def.args[2]
        -     if struct_head_def.head == :(<:)
        -         struct_head = struct_head_def.args[1].args[1]
        -     elseif struct_head_def.head == :curly
        -         struct_head = struct_head_def.args[1]
        -     else
        -         throw(ParseError("invalid expression for struct head: $struct_head_def"))
        -     end
        -
        -     descriptions = String[]
        -     for i in 1:length(struct_fields.args)
        -         #it could be a LineNumberNode
        -         arg_i = struct_fields.args[i]
        -
        -         if arg_i isa Expr
        -             if arg_i.head == :tuple
        -                 tuple_expr = arg_i.args
        -             elseif arg_i.head == :(::)
        -                 tuple_expr = Any[arg_i,:nothing,""] #no metadata provided
        -             end
        -             if length(tuple_expr) > 1
        -                 bounds = tuple_expr[2] #bounds provided
        -             else
        -                 bounds = :nothing #default, converted to (-Inf,Inf)
        -             end
        -
        -             if length(tuple_expr) > 2
        -                 description_i = tuple_expr[3] #description provided
        -             else
        -                 description_i = "" #default
        -             end
        -
        -             if bounds isa Expr && bounds.head == :tuple
        -                 lb_i = bounds.args[1]
        -                 ub_i = bounds.args[2]
        -                 push!(_lb,lb_i)
        -                 push!(_ub,ub_i)
        -             else
        -                 push!(_lb,-Inf)
        -                 push!(_ub,Inf)
        -             end
        -             push!(descriptions,description_i)
        -             struct_fields.args[i] = tuple_expr[1]
        -         end
        -     end
        -     replace!(_lb,:(-Inf)=>-Inf)
        -     replace!(_ub,:(Inf)=>Inf)
        -     float_lb = map(Float64,_lb)
        -     float_ub = map(Float64,_ub)
        -     lb_tuple = Expr(:tuple,float_lb...)
        -     ub_tuple = Expr(:tuple,float_ub...)
        -     descriptions_tuple = Expr(:tuple,descriptions...)
        -     quote
        -         Base.@__doc__ $struct_def
        -
    93451         function Langmuir.isotherm_lower_bound(::Type{TT},::Type{M}) where {TT,M <: $struct_head}
    93451             return TT.($lb_tuple)
        -         end
        -
    93451         function Langmuir.isotherm_upper_bound(::Type{TT},::Type{M}) where {TT,M <: $struct_head}
    93451             return TT.($ub_tuple)
        -         end
        -
        3         function Langmuir.isotherm_descriptions(::Type{M}) where {M <: $struct_head}
        3             return $descriptions_tuple
        -         end
        -     end |> esc
        - end
        -
        - export isotherm_lower_bound, isotherm_upper_bound, model_length
        - export IsothermModel
        -
        - include("freundlich.jl")
        - include("langmuirs1.jl")
        - include("null.jl")
        - include("langmuir_freundlich.jl")
        - include("redlich_peterson.jl")
        - include("sips.jl")
        - include("quadratic.jl")
        - include("bet.jl")
        - include("henry.jl")
        - include("temkin.jl")
        - include("unilan.jl")
        - include("Toth.jl")
        - include("multisite.jl")
        - include("interpolation.jl")
        - include("thermodynamic_langmuir.jl")
        - include("anti_langmuir.jl")
        - include("bingel_walton.jl")
        - include("obrien_myers.jl")
