        - struct AbsorbedIsothermData{TT} <: Tables.AbstractColumns
        6     p::Vector{TT}
        -     l::Vector{TT}
        -     T::Vector{TT}
        -     p_label::Symbol
        -     l_label::Symbol
        -     T_label::Symbol
        - end
        -
        - const AdsIsoTData = AbsorbedIsothermData
        -
        - #= function isotherm_data(p::P,l::L,p_label::Symbol,l_label::Symbol) where {P,L}
        -     return AbsorbedIsothermData(p,l,zeros(eltype(p),length(p)),p_label,l_label,:T)
        - end =#
        -
        - function isotherm_data(p::P, l::L, p_label::Symbol, l_label::Symbol; fill_T = zeros(eltype(p))) where {P, L}
        -
        -     return AbsorbedIsothermData(p, l, fill(fill_T, length(p)), p_label, l_label, :T)
        -
        - end
        -
        - function merge_isotherm_data(tables::AdsIsoTData{TT}...) where TT
        -     row_tables = map(Tables.rowtable, tables)
        -     concatenated_rows = vcat(row_tables...)
        -     return Tables.columntable(concatenated_rows)
        - end
        -
        6 function isotherm_data(p::P,l::L,t::T,p_label::Symbol,l_label::Symbol,T_label::Symbol) where {P,L,T}
        6     @assert length(p) == length(l) == length(t)
        6     @assert p_label != l_label
        6     @assert p_label != T_label
        6     @assert l_label != T_label
        6     TT = Base.promote_eltype(p,l,t)
        6     n = length(p)
       11     pp = Vector{TT}(undef,n)
       11     ll = Vector{TT}(undef,n)
       11     tt = Vector{TT}(undef,n)
        -
        6     if n > 0
        5         pmin = minimum(p)
        5         if pmin < 0
        0             throw(DomainError(pmin,"adsorbed input pressure must be positive"))
        -         end
       10         if !issorted(p)
        1             idx = sortperm(p) # Sort original p
        2             pp .= p[idx]
        2             ll .= l[idx]
        2             tt .= t[idx]
        -         else
        8             pp .= p
        8             ll .= l
        4             tt .= t
        -         end
        -     else # n == 0, vectors are already empty and correctly typed via undef,n. Or pp,ll,tt remain Vector{TT}(undef,0)
        -         # If p, l, t were Any[], TT could be Any. Forcing to Float64[] if completely empty.
        -         # However, if input `p` was e.g. Float64[], TT will be Float64.
        -         # The lines below ensure pp, ll, tt are copies, empty if p,l,t are empty.
        1         pp .= p
        1         ll .= l
        1         tt .= t
        -     end
        6     return AbsorbedIsothermData{TT}(pp,ll,tt,p_label,l_label,T_label)
        - end
        -
        - isotherm_data(p::AbstractVector,l::AbstractVector) = isotherm_data(p,l,zeros(eltype(p),length(p)))
        - isotherm_data(p::AbstractVector,l::AbstractVector,T::AbstractVector) = isotherm_data(p,l,T,:p,:l,:T)
        -
        - function isotherm_data(table,p_label::String,l_label::String,T_label::String)
        -     return isotherm_data(table,Symbol(p_label),Symbol(l_label),Symbol(T_label))
        - end
        -
        6 function isotherm_data(table,p_label::Symbol,l_label::Symbol,T_label::Symbol)
        6     if Tables.istable(table)
        6         p = Tables.getcolumn(table,p_label)
        6         l = Tables.getcolumn(table,l_label)
        6         T = Tables.getcolumn(table,T_label)
        6          return isotherm_data(p,l,T,p_label,l_label,T_label)
        -     else
        0         throw(ArgumentError("table must be a Tables.jl table"))
        -     end
        - end
        -
        - function isotherm_data(table)
        -     return isotherm_data(table,keys(table)...)
        - end
        -
        - #Tables.jl api, column access
        -
        - Tables.istable(::Type{<:AbsorbedIsothermData}) = true
        - Tables.columnaccess(::Type{<:AbsorbedIsothermData}) = true
        1 function Tables.schema(m::AbsorbedIsothermData{T}) where {T}
        -
        1     Tables.Schema(Tables.columnnames(m), (T,T,T))
        - end
        1 Tables.columns(m::AbsorbedIsothermData) = m
        -
       25 function Tables.getcolumn(table::AbsorbedIsothermData, nm::Symbol)
       25     p_label,l_label,T_label = getfield(table,4),getfield(table,5),getfield(table,6)
       25     if nm == p_label
        9         return getfield(table,1)
       16     elseif nm == l_label
        8         return getfield(table,2)
        8     elseif nm == T_label
        8         return getfield(table,3)
        -     else
        0         throw(KeyError(nm))
        -     end
        - end
        -
       18 function Tables.getcolumn(table::AbsorbedIsothermData, nm::Int)
       18     if nm == 1 || nm == 2 || nm == 3
       18         return getfield(table,nm)
        -     else
        0         throw(BoundsError(table,nm))
        -     end
        - end
        -
        - function Tables.getcolumn(m::AbsorbedIsothermData, ::Type{T}, col::Int, nm::Symbol) where {T}
        -     return Tables.getcolumn(m, col)
        - end
        -
        3 Tables.columnnames(table::AbsorbedIsothermData) = (getfield(table,4),getfield(table,5),getfield(table,6))
        -
        - Base.eltype(::Type{<:AbsorbedIsothermData{T}}) where {T} = T
        3 Base.eltype(::AbsorbedIsothermData{T}) where {T} = T
        -
        6 temperature(m::AbsorbedIsothermData) = Tables.getcolumn(m,3)
        6 loading(m::AbsorbedIsothermData) = Tables.getcolumn(m,2)
        6 pressure(m::AbsorbedIsothermData) = Tables.getcolumn(m,1)
        -
        -
        -
        4 function split_data_by_temperature(data::AdsIsoTData{TT}) where TT
        4     l = loading(data)
        4     p = pressure(data)
        4     t = temperature(data)
        -
        4     unique_temps = sort(unique(t))  # Sort unique temperatures in increasing order
        8     temp_data = Vector{Tuple{Vector{TT}, Vector{TT}}}(undef, length(unique_temps))
        -
        4     for (i, temp) in enumerate(unique_temps)
       13         indices = findall(t .== temp)
       13         l_temp = l[indices]
       13         p_temp = p[indices]
       13         temp_data[i] = (l_temp, p_temp)
       22     end
        -
        4     return unique_temps, temp_data
        - end
        -
        - export AbsorbedIsothermData, isotherm_data, split_data_by_temperature, merge_isotherm_data
